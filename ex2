import math
import numpy as np
import matplotlib.pyplot as plt

xfile = open("ex2data1.txt",'r')

X = []
y = []
addm = []
for row in xfile:
    X.append(float(row[:row.find(',')]))
    y.append(float(row[row.find(',') + 1:row.rfind(',')]))
    addm.append((row[row.rfind(',')+1:-1]))

negX = []
negy = []
posX = []
posy = []
for i in range(len(X)):
    if addm[i] == '0':
        negX.append(X[i])
        negy.append(y[i])
    else:
        posX.append(X[i])
        posy.append(y[i])


plt.plot(negX,negy,'yo')
plt.plot(posX,posy,'k+')
#plt.show()

Xmatrix = np.ones([len(X),1])
Xmatrix[:,0] = X
X = Xmatrix

ymatrix = np.ones([len(y),1])
ymatrix[:,0] = y
y = ymatrix

theta = np.zeros([1,3])
iters = 1500


def sigmoid(z):
    return 1 / ( 1 + (math.e ** (-z)))




def computeCost(X,y,theta):
    sum = 0
    for i in range(len(X)):
        sum += (-y[i,0]) * math.log(sigmoid(theta[:,0] + theta[:,1] * X[i,0] + theta[:,2] * y[i,0])) - (1-y[i,0]) * math.log(1 - (sigmoid(theta[:,0] + theta[:,1] * X[i,0] + theta[:,2] * y[i,0])))
    return sum / len(X)

print(computeCost(X,y,theta))


def gradientDescent(X,y,theta,iters):
    cost = computeCost(X,y,theta)
    theta = theta
    thetheta = theta
    for k in range(iters):
        newtheta = theta
        d1 = (np.sum((np.sum(sigmoid(theta[:,0] + theta[:,1] * X[:,0] + theta[:,2] * y[:,0]) - y[:,0]))*1)/len(X))
        if d1 <= (-100):
            newtheta[:, 0] = newtheta[:,0] + 1
        elif d1 <= 0:
            newtheta[:, 0] = newtheta[:,0] + 0.1
        elif 100 <= d1:
            newtheta[:, 0] = newtheta[:,0] - 1
        else:
            newtheta[:, 0] = newtheta[:,0] - 0.1
        d2 = (np.sum((np.sum(sigmoid(theta[:,0] + theta[:,1] * X[:,0] + theta[:,2] * y[:,0]) - y[:,0]))*X[:,0])/len(X))
        if d2 <= (-100):
            newtheta[:,1] = newtheta[:,1] + 1
        elif d2 <= 0:
            newtheta[:, 1] = newtheta[:, 1] + 0.1
        elif 100 <= d2:
            newtheta[:, 1] = newtheta[:, 1] - 1
        else:
            newtheta[:, 1] = newtheta[:, 1] - 0.1
        d3 = (np.sum((np.sum(sigmoid(theta[:,0] + theta[:,1] * X[:,0] + theta[:,2] * y[:,0]) - y[:,0]))*y[:,0])/len(X))
        if d3 <= (-100):
            newtheta[:,2] = newtheta[:,2] + 1
        elif d3 <= 0:
            newtheta[:, 2] = newtheta[:, 2] + 0.1
        elif 100 <= d3:
            newtheta[:, 2] = newtheta[:, 2] - 1
        else:
            newtheta[:, 2] = newtheta[:, 2] - 0.1
        newcost = computeCost(X, y, newtheta)
        if newcost < cost:
            cost = newcost
            thetheta = newtheta
        theta = newtheta
    return thetheta, cost

g ,cost = (gradientDescent(X,y,theta,iters))

plt.plot(X, (g[:,0]+g[:,1]*X[:,0]+g[:,2]*y[:,0]), color='blue', linewidth=1)
plt.show()

















